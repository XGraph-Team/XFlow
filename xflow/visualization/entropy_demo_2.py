# -*- coding: utf-8 -*-
"""IJCAI Demo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Rslj_mz0mLHeSsNpEqWY7bneliHBmLhD
"""

# !pip install -U dash==1.19.0

# !pip install --upgrade dash werkzeug

# !pip install ndlib

import dash
from dash import dcc, html
import plotly.graph_objs as go
from dash.dependencies import Input, Output, State
import networkx as nx
import numpy as np
import random
import scipy.stats
from scipy.stats import entropy
import time

# Function to create a small-world graph
def create_small_world_graph(n=1500, k=5, p=0.3):
    """
    Creates a small world graph using the Watts-Strogatz model.
    n: number of nodes
    k: Each node is connected to k nearest neighbors in ring topology
    p: The probability of rewiring each edge
    """
    return nx.watts_strogatz_graph(n, k, p)

# Function for the SIR model simulation
def SIR_simulation(graph, beta=0.5, gamma=0.05, initial_infected=1, max_steps=1000, interval=10):
    """
    Simulates the SIR model on a graph.
    graph: networkx graph
    beta: infection rate
    gamma: recovery rate
    initial_infected: number of initially infected nodes
    max_steps: maximum number of steps to simulate
    """
    # Initialize statuses
    susceptible = set(graph.nodes())
    infected = set(random.sample(graph.nodes(), initial_infected))
    recovered = set()

    # Records for plotting
    S, I, R = [], [], []
    SI, IR, SR, SS, II, RR = [], [], [], [], [], []

    status_record = []

    for step in range(max_steps):
        # Update statuses
        new_infected = set()
        new_recovered = set()

        # Check infection spread
        for i in infected:
            for neighbor in graph.neighbors(i):
                if neighbor in susceptible and random.random() < beta:
                    new_infected.add(neighbor)

        # Update recovered
        for i in infected:
            if random.random() < gamma:
                new_recovered.add(i)

        # Update sets
        infected |= new_infected
        infected -= new_recovered
        recovered |= new_recovered
        susceptible -= new_infected

        # Update records
        S.append(len(susceptible))
        I.append(len(infected))
        R.append(len(recovered))

        # Record status at specified interval
        if step % interval == 0:
            status_record.append({'S': set(susceptible), 'I': set(infected), 'R': set(recovered)})

        # Edge counts
        ss, ii, rr, si, ir, sr = 0, 0, 0, 0, 0, 0
        for u, v in graph.edges():
            u_status = 'S' if u in susceptible else 'I' if u in infected else 'R'
            v_status = 'S' if v in susceptible else 'I' if v in infected else 'R'

            if u_status == 'S' and v_status == 'S': ss += 1
            elif u_status == 'I' and v_status == 'I': ii += 1
            elif u_status == 'R' and v_status == 'R': rr += 1
            elif (u_status == 'S' and v_status == 'I') or (u_status == 'I' and v_status == 'S'): si += 1
            elif (u_status == 'I' and v_status == 'R') or (u_status == 'R' and v_status == 'I'): ir += 1
            elif (u_status == 'S' and v_status == 'R') or (u_status == 'R' and v_status == 'S'): sr += 1

        SI.append(si)
        IR.append(ir)
        SR.append(sr)
        SS.append(ss)
        II.append(ii)
        RR.append(rr)

        # End if no infected left
        if not infected:
            break

    return S, I, R, status_record, SI, IR, SR, SS, II, RR

# Function to calculate entropy
def calculate_entropy(counts):
    total = sum(counts)
    if total == 0:
        return 0
    probabilities = [c / total for c in counts]
    return entropy(probabilities, base=2)

def plot_networkx_graph(graph, status=None):
    pos = nx.spring_layout(graph)  # Generate positions for all nodes

    # Initialize node color list
    node_color = []
    if status is None:
        node_color = ['gray' for node in graph.nodes()]  # Default color if no status is provided
    else:
        # Assign colors based on SIR status
        for node in graph.nodes():
            if node in status['S']:
                node_color.append('blue')  # Color for Susceptible
            elif node in status['I']:
                node_color.append('red')  # Color for Infected
            elif node in status['R']:
                node_color.append('green')  # Color for Recovered
            else:
                node_color.append('black')  # Color for nodes not in S, I, or R

    # Plotting edges (same as before)
    edge_x = []
    edge_y = []
    for edge in graph.edges():
        # x0, y0 = pos[edge[0]]
        # x1, y1 = pos[edge[1]]
        # edge_x.append(x0)
        # edge_x.append(x1)
        # edge_x.append(None)
        # edge_y.append(y0)
        # edge_y.append(y1)
        # edge_y.append(None)
        x0, y0 = pos[edge[0]]
        x1, y1 = pos[edge[1]]
        edge_x += [x0, x1, None]
        edge_y += [y0, y1, None]

    # Plotting nodes
    node_x = [pos[node][0] for node in graph.nodes()]
    node_y = [pos[node][1] for node in graph.nodes()]
    node_trace = go.Scatter(
        x=node_x, y=node_y,
        mode='markers',
        hoverinfo='text',
        marker=dict(
            showscale=False,
            color=node_color,  # Use node_color list for coloring nodes
            size=10,
            line_width=2),
            showlegend=False  # Set showlegend to False for the nodes trace
        )

    # Define legend labels
    legend_labels = ['Susceptible (S)', 'Infected (I)', 'Recovered (R)', 'Other']

    fig = go.Figure(data=[
        go.Scatter(x=edge_x, y=edge_y, line=dict(width=0.5, color='#888'), hoverinfo='none', mode='lines', showlegend=False),
        node_trace
    ],
    layout=go.Layout(
        showlegend=True,
        hovermode='closest',
        margin=dict(b=0, l=0, r=0, t=0),
        xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
        yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
        legend=dict(x=0.01, y=0.99, borderwidth=1, itemsizing='constant', itemwidth=30,
                    font=dict(family="Courier", size=12, color="black")),
        legend_title_text='SIR Status',
        legend_traceorder='normal',
        legend_bgcolor='LightSteelBlue',
        legend_borderwidth=2,
        legend_bordercolor='Black',
        legend_itemsizing='constant',
        legend_itemwidth=30,
        legend_font=dict(family="Courier", size=12, color="black"),
        legend_title=dict(text="SIR Status", font=dict(family="Courier", size=12, color="black"))
    ))

    # Add legend items with consistent styling
    for color, label in zip(['blue', 'red', 'green', 'black'], legend_labels):
        fig.add_trace(go.Scatter(x=[None], y=[None], mode='markers',
                                 marker=dict(size=10, color=color),
                                 showlegend=True, name=label))

    return fig

# Generate a small-world graph
graph = create_small_world_graph()

# SIR model simulation
S, I, R, status_record, SI, IR, SR, SS, II, RR = SIR_simulation(graph)

# Combine SIR status information into a dictionary
status = {'S': set(S), 'I': set(I), 'R': set(R)}

# Entropy calculations
entropy_S = [calculate_entropy([s, sum(I) - i, sum(R) - r]) for s, i, r in zip(S, I, R)]
entropy_I = [calculate_entropy([sum(S) - s, i, sum(R) - r]) for s, i, r in zip(S, I, R)]
entropy_R = [calculate_entropy([sum(S) - s, sum(I) - i, r]) for s, i, r in zip(S, I, R)]
combined_entropy = [calculate_entropy([s, i, r]) for s, i, r in zip(S, I, R)]
combined_SR_entropy = [calculate_entropy([s + r, i]) for s, i, r in zip(S, I, R)]

# Eigenvalues of graph Laplacian and adjacency matrix
# laplacian_eigenvalues = nx.laplacian_spectrum(graph)
# adjacency_eigenvalues = nx.adjacency_eigenvalues(graph)

L = nx.normalized_laplacian_matrix(graph)
laplacian_eigenvalues = np.linalg.eigvals(L.toarray())
adjacency_eigenvalues = nx.adjacency_spectrum(graph)

# Initialize Dash app
app = dash.Dash(__name__)

# Dash app layout with two columns
app.layout = html.Div([
    html.H1('Network Analysis with SIR Model 2'),
    dcc.Store(id='interval-index', data=0),  # Store for current interval index

    # Row for content
    html.Div([
        # Left column for textual content or additional information
        html.Div([
            # Generate the plot with SIR status information
            dcc.Graph(id='network-graph', figure=plot_networkx_graph(graph, status))
            # dcc.Graph(id='network-graph', figure=plot_networkx_graph(graph))
        # ], className="six columns"),
        ], style={'width': '50%', 'display': 'inline-block'}),  # Inline style for left column

        # Right column with embedded two columns
        html.Div([
            # Embedded left column within the right column
            html.Div([
                dcc.Graph(
                  id='sum-of-energy',
                  figure={
                      'data': [
                          go.Scatter(y=np.array(SI) + np.array(IR), mode='lines', name='Neighbor-Energy'),
                          go.Scatter(y=I, mode='lines', name='Self-Energy')
                      ],
                      'layout': go.Layout(
                          title='Sum of Energy Over Time',
                          xaxis={'title': 'Step'},
                          yaxis={'title': 'Number of Edges'},
                          legend=dict(x=0.01, y=0.99, bordercolor="Black", borderwidth=1)  # Adjust these values as needed
                      )
                  }
              ),
              dcc.Graph(
                  id='sir-model',
                  figure={
                      'data': [
                          go.Scatter(y=S, mode='lines', name='Susceptible'),
                          go.Scatter(y=I, mode='lines', name='Infected'),
                          go.Scatter(y=R, mode='lines', name='Recovered')
                      ],
                      'layout': go.Layout(
                          title='SIR Model Over Time',
                          xaxis={'title': 'Step'},
                          yaxis={'title': 'Number of Nodes'},
                          legend=dict(x=0.01, y=0.99, bordercolor="Black", borderwidth=1)  # Adjust these values as needed
                      )
                  }
              ),
            ], style={'width': '50%', 'display': 'inline-block'}),  # Inline style for embedded left column

            # Embedded right column within the right column
            html.Div([
                dcc.Graph(
                    id='entropy-separate-statuses',
                    figure={
                        'data': [
                            go.Scatter(y=entropy_S, mode='lines', name='Entropy of S', line=dict(color='blue')),
                            go.Scatter(y=entropy_I, mode='lines', name='Entropy of I', line=dict(color='red')),
                            go.Scatter(y=entropy_R, mode='lines', name='Entropy of R', line=dict(color='green'))
                        ],
                        'layout': go.Layout(
                            title='Entropy of Separate Statuses Over Time',
                            xaxis={'title': 'Step'},
                            yaxis={'title': 'Entropy'},
                            # legend={'x': 1, 'y': 1}
                            legend=dict(x=0.01, y=0.99, bordercolor="Black", borderwidth=1)  # Adjust these values as needed
                        )
                    }
                ),
                dcc.Graph(
                    id='combined-entropy',
                    figure={
                        'data': [
                            go.Scatter(y=combined_entropy, mode='lines', name='Combined Entropy', line=dict(color='purple'))
                        ],
                        'layout': go.Layout(
                            title='Entropy of All Statuses Over Time',
                            xaxis={'title': 'Step'},
                            yaxis={'title': 'Entropy'},
                            # legend={'x': 1, 'y': 1}
                            legend=dict(x=0.01, y=0.99, bordercolor="Black", borderwidth=1)  # Adjust these values as needed
                        )
                    }
                )
            ], style={'width': '50%', 'display': 'inline-block'}),  # Inline style for embedded right column
        ], style={'display': 'flex', 'width': '50%'}),  # Style for the right column to display its children inline
    ], style={'display': 'flex'}),  # This ensures that the divs are placed side by side
    
    # Interval component to trigger updates
    dcc.Interval(
        id='interval-component',
        interval=1000,  # in milliseconds
        n_intervals=0
    )
])

# Define callback to update network plot based on interval and interval index
@app.callback(
    [Output('network-graph', 'figure'),
     Output('interval-index', 'data')],
    [Input('interval-component', 'n_intervals')],
    [State('interval-index', 'data')]
)
def update_network_plot_and_index(n_intervals, interval_index):
    # Check if it's time to update based on interval index
    if n_intervals == interval_index:
        # Increment interval index
        new_index = min(interval_index + 1, len(status_record) - 1)
        return plot_networkx_graph(graph, status_record[n_intervals - 1]), new_index
    else:
        # Return previous plot and interval index
        return dash.no_update, interval_index




# Run the app
if __name__ == '__main__':
    app.run_server(debug=True)
